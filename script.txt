eval := (e,  env) => {
    switch (e) {
    case (int i):
        return i;
    case (`Add, i1, i2):
        return eval i1 env + eval i2 env;
    case (`Var, name):
        switch (env::find(name)) {
            case (`Fun, _, _, _):
                return 0;
            case (int i):
                return i;
        }
    case (`App, fname, args):
        switch (env::find(fname)) {
            case (`Fun, fname, ps, body):
                env = env::prepend(zip(ps, args));
                return eval(body, env)
            case _:
                return 0;
        }
    }
}

x = someFunc(); // x : X, ⊥ ⊆ X ⊆ ⊤, x.a = 0
b = someBool; // b : Bool
var y;

if (b) {
    y = true;
} else {
    y = x;
}
// y : {x} ∪ {true}

x.a = 1;
if (y.a == 0) {
    // ...
}

x = 3

eval(expr) {                             // expr : X ⊆ int ∪ bool ∪ Ad ∪ An ∪ E ∪ I
    switch(expr) {                       // eval : X -> int ∪ bool
        case int i:                      // i : int
            return i;
        case bool b:                     // b : bool
            return b;
        case ('Add, e1, e2):             // ('Add, e1, e2) : Ad ⊆ ⟨⊤[3], [[1] : 'Add, [2] : X, [3] : X]⟩
            return eval(e1) + eval(e2);
        case ('And, e1, e2):             
            return eval(e1) && eval(e2); // ('And, e1, e2) : An ⊆ ⟨⊤[3], [[1] : 'And, [2] : X, [3] : X]⟩
        case ('Eq0, e):
            return eval(e) == 0;
        case ('If, b, e1, e2):
            var b' = eval(b);
            if (b') {
                return eval(e1);
            } else {
                return eval(e2);
            }
    }
}

